// ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command

#![allow(unused_unsafe)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::undocumented_unsafe_blocks)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::unused_unit)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::let_and_return)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::needless_borrow)]
#![allow(clippy::clone_on_copy)]

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_Elem {
    Rect = 0,
    Text = 1,
}

impl core::fmt::Debug for discriminant_Elem {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Rect => f.write_str("discriminant_Elem::Rect"),
            Self::Text => f.write_str("discriminant_Elem::Text"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[repr(C)]
pub union Elem {
    Rect: R2,
    Text: core::mem::ManuallyDrop<R3>,
    _sizer: [u8; 44],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_Event {
    KeyDown = 0,
    KeyUp = 1,
    Resize = 2,
    Tick = 3,
}

impl core::fmt::Debug for discriminant_Event {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::KeyDown => f.write_str("discriminant_Event::KeyDown"),
            Self::KeyUp => f.write_str("discriminant_Event::KeyUp"),
            Self::Resize => f.write_str("discriminant_Event::Resize"),
            Self::Tick => f.write_str("discriminant_Event::Tick"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union Event {
    KeyDown: KeyCode,
    KeyUp: KeyCode,
    Resize: Bounds,
    Tick: roc_std::U128,
    _sizer: [u8; 32],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Debug, Default, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Bounds {
    pub height: f32,
    pub width: f32,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R1 {
    // pub init: TODO_roc_function_65,
    // pub render: TODO_roc_function_69,
    // pub update: TODO_roc_function_67,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum KeyCode {
    Down = 0,
    Left = 1,
    Other = 2,
    Right = 3,
    Up = 4,
}

impl core::fmt::Debug for KeyCode {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Down => f.write_str("KeyCode::Down"),
            Self::Left => f.write_str("KeyCode::Left"),
            Self::Other => f.write_str("KeyCode::Other"),
            Self::Right => f.write_str("KeyCode::Right"),
            Self::Up => f.write_str("KeyCode::Up"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[derive(Clone, Debug, Default, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R3 {
    pub color: Rgba,
    pub left: f32,
    pub size: f32,
    pub text: roc_std::RocStr,
    pub top: f32,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Debug, Default, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R2 {
    pub color: Rgba,
    pub height: f32,
    pub left: f32,
    pub top: f32,
    pub width: f32,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Debug, Default, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Rgba {
    pub a: f32,
    pub b: f32,
    pub g: f32,
    pub r: f32,
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union Elem {
    Rect: R2,
    Text: core::mem::ManuallyDrop<R3>,
    _sizer: [u8; 64],
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Default, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R3 {
    pub text: roc_std::RocStr,
    pub color: Rgba,
    pub left: f32,
    pub size: f32,
    pub top: f32,
}

impl Elem {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Elem {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Elem>(*bytes.as_ptr().add(40))
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Elem) {
        let discriminant_ptr: *mut discriminant_Elem = (self as *mut Elem).cast();

        unsafe {
            *(discriminant_ptr.add(40)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Rect`, with the appropriate payload
    pub fn Rect(arg0: R2) -> Self {
            let mut answer = Self {
                Rect: arg0
            };

            answer.set_discriminant(discriminant_Elem::Rect);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Elem` has a `.discriminant()` of `Rect` and convert it to `Rect`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Rect`.
            pub unsafe fn into_Rect(self) -> R2 {
                debug_assert_eq!(self.discriminant(), discriminant_Elem::Rect);
        let payload = self.Rect;

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Elem` has a `.discriminant()` of `Rect` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Rect`.
            pub unsafe fn as_Rect(&self) -> &R2 {
                debug_assert_eq!(self.discriminant(), discriminant_Elem::Rect);
        let payload = &self.Rect;

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Text`, with the appropriate payload
    pub fn Text(arg0: R3) -> Self {
            let mut answer = Self {
                Text: core::mem::ManuallyDrop::new(arg0)
            };

            answer.set_discriminant(discriminant_Elem::Text);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Elem` has a `.discriminant()` of `Text` and convert it to `Text`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Text`.
            pub unsafe fn into_Text(mut self) -> R3 {
                debug_assert_eq!(self.discriminant(), discriminant_Elem::Text);
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.Text,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Elem` has a `.discriminant()` of `Text` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Text`.
            pub unsafe fn as_Text(&self) -> &R3 {
                debug_assert_eq!(self.discriminant(), discriminant_Elem::Text);
        let payload = &self.Text;

        
        payload
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Elem {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Elem>(*bytes.as_ptr().add(56))
        }
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Elem) {
        let discriminant_ptr: *mut discriminant_Elem = (self as *mut Elem).cast();

        unsafe {
            *(discriminant_ptr.add(56)) = discriminant;
        }
    }
}

impl Drop for Elem {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
                    match self.discriminant() {
                discriminant_Elem::Rect => {}
                discriminant_Elem::Text => unsafe { core::mem::ManuallyDrop::drop(&mut self.Text) },
            }

    }
}

impl PartialEq for Elem {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
            match self.discriminant() {
                discriminant_Elem::Rect => self.Rect == other.Rect,
                discriminant_Elem::Text => self.Text == other.Text,
            }
        }
    }
}

impl PartialOrd for Elem {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_Elem::Rect => self.Rect.partial_cmp(&other.Rect),
                discriminant_Elem::Text => self.Text.partial_cmp(&other.Text),
            }
        }
    }
}

impl Clone for Elem {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_Elem::Rect => Self {
                    Rect: self.Rect.clone(),
                },
                discriminant_Elem::Text => Self {
                    Text: self.Text.clone(),
                },
            }

        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::fmt::Debug for Elem {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("Elem::")?;

        unsafe {
            match self.discriminant() {
                discriminant_Elem::Rect => f.debug_tuple("Rect")
        .field(&self.Rect)
        .finish(),
                discriminant_Elem::Text => f.debug_tuple("Text")
        .field(&*self.Text)
        .finish(),
            }
        }
    }
}

impl Event {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Event {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Event>(*bytes.as_ptr().add(16))
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Event) {
        let discriminant_ptr: *mut discriminant_Event = (self as *mut Event).cast();

        unsafe {
            *(discriminant_ptr.add(16)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `KeyDown`, with the appropriate payload
    pub fn KeyDown(arg: KeyCode) -> Self {
            let mut answer = Self {
                KeyDown: arg
            };

            answer.set_discriminant(discriminant_Event::KeyDown);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Event` has a `.discriminant()` of `KeyDown` and convert it to `KeyDown`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `KeyDown`.
            pub unsafe fn into_KeyDown(self) -> KeyCode {
                debug_assert_eq!(self.discriminant(), discriminant_Event::KeyDown);
        let payload = self.KeyDown;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Event` has a `.discriminant()` of `KeyDown` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `KeyDown`.
            pub unsafe fn as_KeyDown(&self) -> &KeyCode {
                debug_assert_eq!(self.discriminant(), discriminant_Event::KeyDown);
        let payload = &self.KeyDown;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `KeyUp`, with the appropriate payload
    pub fn KeyUp(arg: KeyCode) -> Self {
            let mut answer = Self {
                KeyUp: arg
            };

            answer.set_discriminant(discriminant_Event::KeyUp);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Event` has a `.discriminant()` of `KeyUp` and convert it to `KeyUp`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `KeyUp`.
            pub unsafe fn into_KeyUp(self) -> KeyCode {
                debug_assert_eq!(self.discriminant(), discriminant_Event::KeyUp);
        let payload = self.KeyUp;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Event` has a `.discriminant()` of `KeyUp` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `KeyUp`.
            pub unsafe fn as_KeyUp(&self) -> &KeyCode {
                debug_assert_eq!(self.discriminant(), discriminant_Event::KeyUp);
        let payload = &self.KeyUp;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Resize`, with the appropriate payload
    pub fn Resize(arg0: Bounds) -> Self {
            let mut answer = Self {
                Resize: arg0
            };

            answer.set_discriminant(discriminant_Event::Resize);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Event` has a `.discriminant()` of `Resize` and convert it to `Resize`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Resize`.
            pub unsafe fn into_Resize(self) -> Bounds {
                debug_assert_eq!(self.discriminant(), discriminant_Event::Resize);
        let payload = self.Resize;

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Event` has a `.discriminant()` of `Resize` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Resize`.
            pub unsafe fn as_Resize(&self) -> &Bounds {
                debug_assert_eq!(self.discriminant(), discriminant_Event::Resize);
        let payload = &self.Resize;

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Tick`, with the appropriate payload
    pub fn Tick(arg: roc_std::U128) -> Self {
            let mut answer = Self {
                Tick: arg
            };

            answer.set_discriminant(discriminant_Event::Tick);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Event` has a `.discriminant()` of `Tick` and convert it to `Tick`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Tick`.
            pub unsafe fn into_Tick(self) -> roc_std::U128 {
                debug_assert_eq!(self.discriminant(), discriminant_Event::Tick);
        let payload = self.Tick;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Event` has a `.discriminant()` of `Tick` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Tick`.
            pub unsafe fn as_Tick(&self) -> &roc_std::U128 {
                debug_assert_eq!(self.discriminant(), discriminant_Event::Tick);
        let payload = &self.Tick;

        &payload
    }
}

impl PartialEq for Event {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
            match self.discriminant() {
                discriminant_Event::KeyDown => self.KeyDown == other.KeyDown,
                discriminant_Event::KeyUp => self.KeyUp == other.KeyUp,
                discriminant_Event::Resize => self.Resize == other.Resize,
                discriminant_Event::Tick => self.Tick == other.Tick,
            }
        }
    }
}

impl PartialOrd for Event {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_Event::KeyDown => self.KeyDown.partial_cmp(&other.KeyDown),
                discriminant_Event::KeyUp => self.KeyUp.partial_cmp(&other.KeyUp),
                discriminant_Event::Resize => self.Resize.partial_cmp(&other.Resize),
                discriminant_Event::Tick => self.Tick.partial_cmp(&other.Tick),
            }
        }
    }
}

impl Copy for Event {}

impl Clone for Event {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_Event::KeyDown => Self {
                    KeyDown: self.KeyDown.clone(),
                },
                discriminant_Event::KeyUp => Self {
                    KeyUp: self.KeyUp.clone(),
                },
                discriminant_Event::Resize => Self {
                    Resize: self.Resize.clone(),
                },
                discriminant_Event::Tick => Self {
                    Tick: self.Tick.clone(),
                },
            }

        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::fmt::Debug for Event {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("Event::")?;

        unsafe {
            match self.discriminant() {
                discriminant_Event::KeyDown => f.debug_tuple("KeyDown")
        .field(&self.KeyDown)
        .finish(),
                discriminant_Event::KeyUp => f.debug_tuple("KeyUp")
        .field(&self.KeyUp)
        .finish(),
                discriminant_Event::Resize => f.debug_tuple("Resize")
        .field(&self.Resize)
        .finish(),
                discriminant_Event::Tick => f.debug_tuple("Tick")
        .field(&self.Tick)
        .finish(),
            }
        }
    }
}
